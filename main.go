package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"

	"golang.org/x/tools/go/loader"
)

func getCustomTypeIface() *types.Interface {
	fset := token.NewFileSet()
	const code = `
	package typeconv

	type GOBE_CUSTOM_TYPE interface {
		MarshalGOBE(dst []byte) uint64
		UnmarshalGOBE(src []byte) (offset uint64, ok bool)
		SizeGOBE() uint64
	}
	`
	f, err := parser.ParseFile(fset, "customtype.go", code, 0)
	if err != nil {
		panic(err)
	}

	conf := types.Config{Importer: importer.Default()}
	pkg, err := conf.Check("typeconv", fset, []*ast.File{f}, nil)
	if err != nil {
		panic(err)
	}

	return pkg.Scope().Lookup("GOBE_CUSTOM_TYPE").Type().Underlying().(*types.Interface).Complete()
}

var customTypeIface = getCustomTypeIface()

func main() {
	os.Remove(filepath.Join(os.Args[1], "gobe_generated.go"))

	var conf loader.Config
	conf.Import(os.Args[1])
	conf.TypeChecker.IgnoreFuncBodies = true
	conf.TypeChecker.DisableUnusedImportCheck = true
	conf.AllowErrors = true
	lp, err := conf.Load()
	if err != nil {
		log.Fatalln(err)
	}

	var pkgname string
	var root *types.Package
	gctx := &context{data: make(map[*types.Named]*AnalysisResult)}
	for _, pkg := range lp.InitialPackages() {
		for _, objs := range pkg.Defs {
			if tn, ok := objs.(*types.TypeName); ok {
				switch t := tn.Type().(type) {
				case *types.Named:
					if t.TypeParams() != nil &&
						t.TypeParams().Len() > 0 &&
						!(t.TypeArgs() != nil && t.TypeArgs().Len() == t.TypeParams().Len()) {
						continue
					}
					analyzeType(gctx, t)
				}
			}
		}
		if pkgname == "" {
			pkgname = pkg.Pkg.Name()
			root = pkg.Pkg
		}
	}

	var tt []*AnalysisResult = make([]*AnalysisResult, 0, len(gctx.data))
	for _, r := range gctx.data {
		if r.Type.Obj().Pkg() != root {
			continue
		}
		if isCustomType(r.Type) {
			continue
		}
		tt = append(tt, r)
	}

	sort.Slice(
		tt,
		func(i, j int) bool {
			return tt[i].Type.Obj().Pkg().Path() <= tt[j].Type.Obj().Pkg().Path() &&
				tt[i].Type.Obj().Name() < tt[j].Type.Obj().Name()
		},
	)

	gctx2 := &GenerateContext{
		Generated:   make(map[*types.Named][]byte),
		LibAlias:    make(map[string]string),
		RootPackage: root,
	}
	for _, r := range tt {
		generateSize(gctx2, r.Type)
		generateMarshal(gctx2, r.Type)
		generateUnmarshal(gctx2, r.Type)
	}

	var generated bytes.Buffer
	generated.WriteString("package ")
	generated.WriteString(pkgname)
	generated.WriteString("\n\n")
	if len(gctx2.LibAlias) > 0 {
		generated.WriteString("import (\n")

		keys := make([]string, 0, len(gctx2.LibAlias))
		for k := range gctx2.LibAlias {
			keys = append(keys, k)
		}
		sort.Strings(keys)

		for _, k := range keys {
			generated.WriteString("\t")
			generated.WriteString(gctx2.LibAlias[k])
			generated.WriteString(" \"")
			generated.WriteString(k)
			generated.WriteString("\"\n")
		}
		generated.WriteString(")\n\n")
	}

	for _, b := range tt {
		formated, err := format.Source(gctx2.Generated[b.Type])
		if err != nil {
			formated = gctx2.Generated[b.Type]
		}
		generated.Write(formated)
		generated.WriteString("\n\n")
	}

	formated, err := format.Source(generated.Bytes())
	if err != nil {
		formated = generated.Bytes()
	}

	// Write to file
	f, err := os.Create(filepath.Join(os.Args[1], "gobe_generated.go"))
	if err != nil {
		panic(err)
	}
	defer f.Close()
	f.Write(formated)
}

func isCustomType(t types.Type) bool {
	// Return true if t implements GOBE_CUSTOM_TYPE
	return types.Implements(t, customTypeIface) ||
		types.Implements(types.NewPointer(t), customTypeIface) ||
		types.AssignableTo(t, customTypeIface) ||
		types.AssignableTo(types.NewPointer(t), customTypeIface)
}

type AnalysisResult struct {
	Type *types.Named
	Ref  map[types.Type]bool
}

func analyzeType(ctx *context, t *types.Named) *AnalysisResult {
	if r, ok := ctx.data[t]; ok {
		return r
	}
	r := &AnalysisResult{Type: t, Ref: make(map[types.Type]bool)}
	ctx.data[t] = r

	switch v := t.Underlying().(type) {
	case *types.Struct:
		for i := 0; i < v.NumFields(); i++ {
			f := v.Field(i)
			if !f.Exported() {
				continue
			}
			r.Ref[f.Type()] = true

			c := &rccContext{ref: make(map[types.Type]bool)}
			rcc(c, f.Type(), func(t *types.Named) {
				ar := analyzeType(ctx, t)
				for k := range ar.Ref {
					r.Ref[k] = true
				}
			})
		}
	}
	return r
}

type rccContext struct {
	ref map[types.Type]bool
}

func rcc(c *rccContext, t types.Type, fn func(t *types.Named)) {
	if c.ref[t] {
		return
	}
	c.ref[t] = true

	switch t := t.(type) {
	case *types.Named:
		fn(t)
		rcc(c, t.Underlying(), fn)
	case *types.Pointer:
		rcc(c, t.Elem(), fn)
	case *types.Slice:
		rcc(c, t.Elem(), fn)
	case *types.Array:
		rcc(c, t.Elem(), fn)
	case *types.Struct:
		for i := 0; i < t.NumFields(); i++ {
			if !t.Field(i).Exported() {
				continue
			}
			rcc(c, t.Field(i).Type(), fn)
		}
	case *types.Map:
		rcc(c, t.Key(), fn)
		rcc(c, t.Elem(), fn)
	}
}

type context struct {
	data map[*types.Named]*AnalysisResult
}

type GenerateContext struct {
	NameCtr     uint64
	Generated   map[*types.Named][]byte
	LibAlias    map[string]string
	RootPackage *types.Package
}

func (ctx *GenerateContext) nextName() string {
	ctx.NameCtr++
	return fmt.Sprintf("ns%d", 25518+ctx.NameCtr)
}

func generateMarshal(ctx *GenerateContext, t *types.Named) {
	name := ctx.nextName()
	//func (name *Type) MarshalGOBE(dst []byte) uint64 {
	ctx.Generated[t] = fmt.Appendf(
		ctx.Generated[t],
		"func (%s *%s) MarshalGOBE(dst []byte) uint64 {\n",
		name, t.Obj().Name(),
	)
	// var __offset uint64
	__offset := ctx.nextName()
	ctx.Generated[t] = fmt.Appendf(
		ctx.Generated[t],
		"    var %s uint64\n\n",
		__offset,
	)

	// <body>
	if v, ok := t.Underlying().(*types.Basic); ok {
		switch v.Kind() {
		}
		generateMarshalBody(ctx, "*"+name, __offset, t, t)
	} else {
		generateMarshalBody(ctx, name, __offset, t, t.Underlying())
	}

	//    return __offset
	//}
	ctx.Generated[t] = fmt.Appendf(
		ctx.Generated[t],
		"\n    return %s\n}\n\n",
		__offset,
	)
}

func generateSize(ctx *GenerateContext, t *types.Named) {
	name := ctx.nextName()
	//func (name *Type) SizeGOBE() uint64 {
	ctx.Generated[t] = fmt.Appendf(
		ctx.Generated[t],
		"func (%s *%s) SizeGOBE() uint64 {\n",
		name, t.Obj().Name(),
	)
	// var __size uint64
	__size := ctx.nextName()
	ctx.Generated[t] = fmt.Appendf(
		ctx.Generated[t],
		"    var %s uint64\n\n",
		__size,
	)

	// <body>
	if v, ok := t.Underlying().(*types.Basic); ok {
		switch v.Kind() {
		}
		generateSizeBody(ctx, "*"+name, __size, t, t)
	} else {
		generateSizeBody(ctx, name, __size, t, t.Underlying())
	}

	//    return __size
	//}
	ctx.Generated[t] = fmt.Appendf(
		ctx.Generated[t],
		"\n    return %s\n}\n\n",
		__size,
	)
}

func generateUnmarshal(ctx *GenerateContext, t *types.Named) {
	name := ctx.nextName()
	//func (name *Type) UnmarshalGOBE(src []byte) (offset uint64, ok bool) {
	ctx.Generated[t] = fmt.Appendf(
		ctx.Generated[t],
		"func (%s *%s) UnmarshalGOBE(src []byte) (offset uint64, ok bool) {\n",
		name, t.Obj().Name(),
	)

	// <body>
	if v, ok := t.Underlying().(*types.Basic); ok {
		switch v.Kind() {
		}
		generateUnmarshalBody(ctx, "*"+name, t, t)
	} else {
		generateUnmarshalBody(ctx, name, t, t.Underlying())
	}

	//    ok = true
	//    return
	//}
	ctx.Generated[t] = fmt.Appendf(
		ctx.Generated[t],
		"\n    ok = true\n    return\n}\n\n",
	)
}

func generateMarshalBody(ctx *GenerateContext, name string, __offset string, rt *types.Named, t types.Type) {
	//    // ZZ: (<type>)(<name>)
	ctx.Generated[rt] = fmt.Appendf(
		ctx.Generated[rt],
		"\n// ZZ: (%s)(%s)\n",
		t.String(), name,
	)

	if isCustomType(t) {
		//    __offset += `v.Name()`.MarshalGOBE(dst[__offset:])
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    %s += %s.MarshalGOBE(dst[%s:])\n",
			__offset, name, __offset,
		)
		return
	}

	switch v := t.(type) {
	case *types.Struct:
		for i := 0; i < v.NumFields(); i++ {
			f := v.Field(i)
			if !f.Exported() {
				continue
			}

			// ignore gobe:"-" fields
			tag := reflect.StructTag(v.Tag(i))
			if tag.Get("gobe") == "-" {
				continue
			}

			generateMarshalBody(ctx, name+"."+f.Name(), __offset, rt, f.Type())
		}
	case *types.Map:
		__len := ctx.nextName()
		//    var __len uint64 = uint64(len(name))
		//    _ = dst[__offset+7]
		//    dst[__offset] = byte(__len >> 0)
		//    dst[__offset+1] = byte(__len >> 8)
		//    dst[__offset+2] = byte(__len >> 16)
		//    dst[__offset+3] = byte(__len >> 24)
		//    dst[__offset+4] = byte(__len >> 32)
		//    dst[__offset+5] = byte(__len >> 40)
		//    dst[__offset+6] = byte(__len >> 48)
		//    dst[__offset+7] = byte(__len >> 56)
		//    __offset += 8
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			`    var %s uint64 = uint64(len(%s))
    _ = dst[%s+7]
`, __len, name, __offset)
		for i := 0; i < 8; i++ {
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    dst[%s+%d] = byte(%s >> %d)\n",
				__offset, i, __len, i*8,
			)
		}
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    %s += 8\n\n",
			__offset,
		)

		//    for __key, __value := range name {
		//        <body for key>
		//        <body for value>
		//    }

		__key := ctx.nextName()
		__value := ctx.nextName()
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    for %s, %s := range %s {\n",
			__key, __value, name,
		)

		generateMarshalBody(ctx, __key, __offset, rt, v.Key())
		generateMarshalBody(ctx, __value, __offset, rt, v.Elem())

		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    }\n\n",
		)
	case *types.Slice:
		if isBasicType(v.Elem()) {
			if basicType(v.Elem()).Kind() == types.Byte {
				// []byte is a special case
				__len := ctx.nextName()
				//    var __len uint64 = uint64(len(name))
				//    _ = dst[__offset+7]
				//    dst[__offset] = byte(__len >> 0)
				//    dst[__offset+1] = byte(__len >> 8)
				//    dst[__offset+2] = byte(__len >> 16)
				//    dst[__offset+3] = byte(__len >> 24)
				//    dst[__offset+4] = byte(__len >> 32)
				//    dst[__offset+5] = byte(__len >> 40)
				//    dst[__offset+6] = byte(__len >> 48)
				//    dst[__offset+7] = byte(__len >> 56)
				//    copy(dst[__offset+8:], name)
				//    __offset += 8 + __len
				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					`    var %s uint64 = uint64(len(%s))
			_ = dst[%s+7]
`, __len, name, __offset)
				for i := 0; i < 8; i++ {
					ctx.Generated[rt] = fmt.Appendf(
						ctx.Generated[rt],
						"    dst[%s+%d] = byte(%s >> %d)\n",
						__offset, i, __len, i*8,
					)
				}
				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					"    copy(dst[%s+8:], %s)\n",
					__offset, name,
				)
				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					"    %s += 8 + %s\n\n",
					__offset, __len,
				)
				return
			}
		}

		__len := ctx.nextName()
		//    var __len uint64 = uint64(len(name))
		//    _ = dst[__offset+7]
		//    dst[__offset] = byte(__len >> 0)
		//    dst[__offset+1] = byte(__len >> 8)
		//    dst[__offset+2] = byte(__len >> 16)
		//    dst[__offset+3] = byte(__len >> 24)
		//    dst[__offset+4] = byte(__len >> 32)
		//    dst[__offset+5] = byte(__len >> 40)
		//    dst[__offset+6] = byte(__len >> 48)
		//    dst[__offset+7] = byte(__len >> 56)
		//    __offset += 8
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			`    var %s uint64 = uint64(len(%s))
    _ = dst[%s+7]
`, __len, name, __offset)
		for i := 0; i < 8; i++ {
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    dst[%s+%d] = byte(%s >> %d)\n",
				__offset, i, __len, i*8,
			)
		}
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    %s += 8\n\n",
			__offset,
		)

		//    for __i := 0; __i < len(name); __i++ {
		//        <body>
		//    }

		__i := ctx.nextName()
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    for %s := 0; %s < len(%s); %s++ {\n",
			__i, __i, name, __i,
		)
		generateMarshalBody(ctx, name+"["+__i+"]", __offset, rt, v.Elem())
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    }\n",
		)
	case *types.Array:
		if isBasicType(v.Elem()) {
			bt := basicType(v.Elem())
			if bt.Kind() == types.Byte {
				if v.Len() <= 32 {
					//    _ = dst[__offset+31]
					//    dst[__offset] = name[0]
					//    dst[__offset+1] = name[1]
					//    ...
					//    __offset += 32

					if v.Len() > 1 { // No BCE optimization for 1 byte
						ctx.Generated[rt] = fmt.Appendf(
							ctx.Generated[rt],
							"    _ = dst[%s+%d]\n",
							__offset, v.Len()-1,
						)
					}
					for i := int64(0); i < v.Len(); i++ {
						ctx.Generated[rt] = fmt.Appendf(
							ctx.Generated[rt],
							"    dst[%s+%d] = %s[%d]\n",
							__offset, i, name, i,
						)
					}
					ctx.Generated[rt] = fmt.Appendf(
						ctx.Generated[rt],
						"    %s += %d\n",
						__offset, v.Len(),
					)
					return
				}

				// NOTE: this is a special case for byte arrays
				//    copy(dst[__offset:], name[:])
				//    __offset += <length>
				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					"    copy(dst[%s:], %s[:])\n",
					__offset, name,
				)
				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					"    %s += %d\n\n",
					__offset, v.Len(),
				)
				return
			}
		}

		//    for __i := 0; __i < <length>; __i++ {
		//        <body>
		//    }
		__i := ctx.nextName()
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    for %s := 0; %s < %d; %s++ {\n",
			__i, __i, v.Len(), __i,
		)
		generateMarshalBody(ctx, name+"["+__i+"]", __offset, rt, v.Elem())
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    }\n",
		)
	case *types.Pointer:
		// TODO: use pointer table
		//    if v != nil {
		//        dst[__offset] = 1
		//        __offset++
		//        <body>
		//    } else {
		//        dst[__offset] = 0
		//        __offset++
		//    }
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    if %s != nil {\n",
			name,
		)
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"        dst[%s] = 1\n",
			__offset,
		)
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"        %s++\n",
			__offset,
		)
		generateMarshalBody(ctx, "(*"+name+")", __offset, rt, v.Elem())
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    } else {\n",
		)
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"        dst[%s] = 0\n",
			__offset,
		)
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"        %s++\n",
			__offset,
		)
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    }\n\n",
		)
	case *types.Named:
		if isBasicType(v.Underlying()) {
			generateMarshalBody(ctx, name, __offset, rt, v.Underlying())
			return
		}

		//    __offset += `v.Name()`.MarshalGOBE(dst[__offset:])
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    %s += %s.MarshalGOBE(dst[%s:])\n",
			__offset, name, __offset,
		)
	case *types.Basic:
		switch v.Kind() {
		case types.Bool:
			//    dst[__offset] = 0
			//    if name {
			//        dst[__offset] = 1
			//    }
			//    __offset++
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    dst[%s] = 0\n",
				__offset,
			)
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    if %s {\n",
				name,
			)
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"        dst[%s] = 1\n",
				__offset,
			)
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    }\n",
			)
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    %s++\n",
				__offset,
			)
		case types.Int, types.Int8, types.Int16, types.Int32, types.Int64:
			var size uint = 8
			switch v.Kind() {
			case types.Int8:
				size = 1
			case types.Int16:
				size = 2
			case types.Int32:
				size = 4
			case types.Int64:
				size = 8
			case types.Int:
				size = 8 // use 64bit for int
			}

			//    var __uint uint`size*8` = uint`size*8`(name)
			//    _ = dst[__offset+size-1]
			//    dst[__offset+0] = byte(__uint >> 0) ...
			__uint := ctx.nextName()
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    var %s uint%d = uint%d(%s)\n",
				__uint, size*8, size*8, name,
			)
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    _ = dst[%s+%d]\n",
				__offset, size-1,
			)

			for i := uint(0); i < size; i++ {
				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					"    dst[%s+%d] = byte(%s >> %d)\n",
					__offset, i, __uint, i*8,
				)
			}

			if size != 1 {
				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					"    %s += %d\n",
					__offset, size,
				)
			} else {
				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					"    %s++\n",
					__offset,
				)
			}
		case types.Uint, types.Uint8, types.Uint16, types.Uint32, types.Uint64, types.Uintptr:
			var size uint = 8
			switch v.Kind() {
			case types.Uint8:
				size = 1
			case types.Uint16:
				size = 2
			case types.Uint32:
				size = 4
			case types.Uint64, types.Uintptr:
				size = 8
			case types.Uint:
				size = 8 // use 64bit for int
			}

			var __uint string = name
			if v.Kind() == types.Uintptr {
				__uint := ctx.nextName()
				//    var __uint uint`size*8` = uint`size*8`(name)
				//    _ = dst[__offset+size-1]
				//    dst[__offset+0] = byte(__uint >> 0) ...
				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					"    var %s uint%d = uint%d(%s)\n",
					__uint, size*8, size*8, name,
				)
			}

			if size != 1 {
				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					"    _ = dst[%s+%d]\n",
					__offset, size-1,
				)
			}

			for i := uint(0); i < size; i++ {
				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					"    dst[%s+%d] = byte(%s >> %d)\n",
					__offset, i, __uint, i*8,
				)
			}

			if size != 1 {
				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					"    %s += %d\n",
					__offset, size,
				)
			} else {
				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					"    %s++\n",
					__offset,
				)
			}
		case types.Float32, types.Float64:
			switch v.Kind() {
			case types.Float32:
				generateFloatMarshal(ctx, name, __offset, rt, 4)
			case types.Float64:
				generateFloatMarshal(ctx, name, __offset, rt, 8)
			}
		case types.Complex64, types.Complex128:
			switch v.Kind() {
			case types.Complex64:
				//   var __real, __imag float32 = float32(real(name)), float32(imag(name))
				//   <generate FloatMarshal>
				__real := ctx.nextName()
				__imag := ctx.nextName()
				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					"    var %s, %s float32 = float32(real(%s)), float32(imag(%s))\n",
					__real, __imag, name, name,
				)
				generateFloatMarshal(ctx, __real, __offset, rt, 4)
				generateFloatMarshal(ctx, __imag, __offset, rt, 4)
			case types.Complex128:
				//   var __real, __imag float64 = float64(real(name)), float64(imag(name))
				//   <generate FloatMarshal>
				__real := ctx.nextName()
				__imag := ctx.nextName()
				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					"    var %s, %s float64 = float64(real(%s)), float64(imag(%s))\n",
					__real, __imag, name, name,
				)
				generateFloatMarshal(ctx, __real, __offset, rt, 8)
				generateFloatMarshal(ctx, __imag, __offset, rt, 8)
			}
		case types.String:
			//    var __len uint64 = uint64(len(name))
			//	  _ = dst[__offset+7]
			//    dst[__offset+0] = byte(__len >> 0)
			//    dst[__offset+1] = byte(__len >> 8)
			//    dst[__offset+2] = byte(__len >> 16)
			//    dst[__offset+3] = byte(__len >> 24)
			//    dst[__offset+4] = byte(__len >> 32)
			//    dst[__offset+5] = byte(__len >> 40)
			//    dst[__offset+6] = byte(__len >> 48)
			//    dst[__offset+7] = byte(__len >> 56)
			//    copy(dst[__offset+8:], name)
			//    __offset += 8 + __len
			__len := ctx.nextName()
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    var %s uint64 = uint64(len(%s))\n",
				__len, name,
			)
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    _ = dst[%s+7]\n",
				__offset,
			)
			for i := uint(0); i < 8; i++ {
				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					"    dst[%s+%d] = byte(%s >> %d)\n",
					__offset, i, __len, i*8,
				)
			}
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    copy(dst[%s+8:], %s)\n",
				__offset, name,
			)
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    %s += 8 + %s\n",
				__offset, __len,
			)
		}
	}
}

func generateSizeBody(ctx *GenerateContext, name string, __size string, rt *types.Named, t types.Type) {
	//    // ZZ: (<type>)(<name>)
	ctx.Generated[rt] = fmt.Appendf(
		ctx.Generated[rt],
		"\n// ZZ: (%s)(%s)\n",
		t.String(), name,
	)

	if isCustomType(t) {
		//    __size += `name`.SizeGOBE()
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    %s += %s.SizeGOBE()\n",
			__size, name,
		)
		return
	}

	switch v := t.(type) {
	case *types.Struct:
		for i := 0; i < v.NumFields(); i++ {
			f := v.Field(i)
			if !f.Exported() {
				continue
			}

			// ignore gobe:"-" fields
			tag := reflect.StructTag(v.Tag(i))
			if tag.Get("gobe") == "-" {
				continue
			}

			generateSizeBody(ctx, name+"."+f.Name(), __size, rt, f.Type())
		}
	case *types.Map:
		//    __size += 8
		//    for __key, __value := range name {
		//        _, _ = __key, __value
		//        <size for key>
		//        <size for value>
		//    }

		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    %s += 8\n",
			__size,
		)
		__key := ctx.nextName()
		__value := ctx.nextName()
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    for %s, %s := range %s {\n",
			__key, __value, name,
		)
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"        _, _ = %s, %s\n",
			__key, __value,
		)

		generateSizeBody(ctx, __key, __size, rt, v.Key())
		generateSizeBody(ctx, __value, __size, rt, v.Elem())

		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    }\n\n",
		)
	case *types.Slice:
		if isBasicType(v.Elem()) {
			if basicType(v.Elem()).Kind() == types.Byte {
				// []byte is a special case
				//    __size += 8 + uint64(len(name))
				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					"    %s += 8 + uint64(len(%s))\n",
					__size, name,
				)
				return
			}
		}

		//    __size += 8
		//    for __i := 0; __i < len(name); __i++ {
		//        <size for element>
		//    }

		__i := ctx.nextName()
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"%s += 8\n"+
				"    for %s := 0; %s < len(%s); %s++ {\n",
			__size, __i, __i, name, __i,
		)
		generateSizeBody(ctx, name+"["+__i+"]", __size, rt, v.Elem())
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    }\n",
		)
	case *types.Array:
		// Scalar types are special cases
		if isBasicType(v.Elem()) {
			bt := basicType(v.Elem())
			switch bt.Kind() {
			case types.Bool,
				types.Int, types.Int8, types.Int16, types.Int32, types.Int64,
				types.Uint, types.Uint8, types.Uint16, types.Uint32, types.Uint64, types.Uintptr,
				types.Float32, types.Float64,
				types.Complex64, types.Complex128:

				var size byte
				switch bt.Kind() {
				case types.Bool, types.Int8, types.Uint8:
					size = 1
				case types.Int16, types.Uint16:
					size = 2
				case types.Int32, types.Uint32, types.Float32:
					size = 4
				case types.Int, types.Int64, types.Uint, types.Uint64, types.Float64, types.Complex64:
					size = 8
				case types.Complex128:
					size = 16
				}

				//    __size += <size> * <length>
				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					"    %s += %d\n",
					__size, int64(size)*v.Len(),
				)
				return
			}
		}

		//    for __i := 0; __i < <length>; __i++ {
		//        <size for element>
		//    }
		__i := ctx.nextName()
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    for %s := 0; %s < %d; %s++ {\n",
			__i, __i, v.Len(), __i,
		)
		generateSizeBody(ctx, name+"["+__i+"]", __size, rt, v.Elem())
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    }\n",
		)
	case *types.Pointer:
		// TODO: use pointer table
		//    __size += 1
		//    if name != nil {
		//        <size for element>
		//    }
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    %s += 1\n",
			__size,
		)
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    if %s != nil {\n",
			name,
		)
		generateSizeBody(ctx, "(*"+name+")", __size, rt, v.Elem())
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    }\n",
		)

	case *types.Named:
		if isBasicType(v.Underlying()) {
			generateSizeBody(ctx, name, __size, rt, v.Underlying())
			return
		}

		//    __size += `name`.SizeGOBE()
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    %s += %s.SizeGOBE()\n",
			__size, name,
		)
	case *types.Basic:
		switch v.Kind() {
		case types.Bool,
			types.Int, types.Int8, types.Int16, types.Int32, types.Int64,
			types.Uint, types.Uint8, types.Uint16, types.Uint32, types.Uint64, types.Uintptr,
			types.Float32, types.Float64,
			types.Complex64, types.Complex128:

			var size byte
			switch v.Kind() {
			case types.Bool, types.Int8, types.Uint8:
				size = 1
			case types.Int16, types.Uint16:
				size = 2
			case types.Int32, types.Uint32, types.Float32:
				size = 4
			case types.Int, types.Int64, types.Uint, types.Uint64, types.Float64, types.Complex64:
				size = 8
			case types.Complex128:
				size = 16
			}

			//    __size += `size`
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    %s += %d\n",
				__size, size,
			)
		case types.String:
			//    __size += 8 + uint64(len(name))
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    %s += 8 + uint64(len(%s))\n",
				__size, name,
			)
		}
	}
}

func generateUnmarshalBody(ctx *GenerateContext, name string, rt *types.Named, t types.Type, type_alias ...types.Type) {
	//    // ZZ: (<type>)(<name>)
	ctx.Generated[rt] = fmt.Appendf(
		ctx.Generated[rt],
		"\n// ZZ: (%s)(%s)\n",
		t.String(), name,
	)

	if isCustomType(t) {
		//    __off, __ok := name.UnmarshalGOBE(src[offset:])
		//    offset += __off
		//    if !__ok {
		//        return
		//    }
		__off := ctx.nextName()
		__ok := ctx.nextName()
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    %s, %s := %s.UnmarshalGOBE(src[offset:])\n"+
				"    offset += %s\n"+
				"    if !%s {\n"+
				"        return\n"+
				"    }\n",
			__off, __ok, name, __off, __ok,
		)
		return
	}

	switch v := t.(type) {
	case *types.Struct:
		for i := 0; i < v.NumFields(); i++ {
			f := v.Field(i)
			if !f.Exported() {
				continue
			}

			// ignore gobe:"-" fields
			tag := reflect.StructTag(v.Tag(i))
			if tag.Get("gobe") == "-" {
				continue
			}

			generateUnmarshalBody(ctx, name+"."+f.Name(), rt, f.Type())
		}
	case *types.Map:
		//    if uint64(len(src)) < offset+8 {
		//        return
		//    }
		//    _ = src[offset+7]
		//    var __mlen uint64 = uint64(src[offset]) | uint64(src[offset+1])<<8 | uint64(src[offset+2])<<16 | uint64(src[offset+3])<<24 | uint64(src[offset+4])<<32 | uint64(src[offset+5])<<40 | uint64(src[offset+6])<<48 | uint64(src[offset+7])<<56
		//    offset += 8
		__mlen := ctx.nextName()
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    if uint64(len(src)) < offset+8 {\n"+
				"        return\n"+
				"    }\n"+
				"    _ = src[offset+7]\n"+
				"    var %s uint64 = uint64(src[offset]) | uint64(src[offset+1])<<8 | uint64(src[offset+2])<<16 | uint64(src[offset+3])<<24 | uint64(src[offset+4])<<32 | uint64(src[offset+5])<<40 | uint64(src[offset+6])<<48 | uint64(src[offset+7])<<56\n"+
				"    offset += 8\n",
			__mlen,
		)

		// Pre-allocate map if less than 32KB
		//   if __mlen <= 1<<15 {
		//       name = make(map[<key>]<value>, __mlen)
		//   } else {
		//       name = make(map[<key>]<value>)
		//   }

		KeyType := getTypeName(ctx, v.Key())
		ValueType := getTypeName(ctx, v.Elem())
		//    // Key: <key>, Value: <value>
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"// Key: %s, Value: %s\n",
			KeyType, ValueType,
		)

		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    if %s <= 1<<15 {\n"+
				"        %s = make(map[%s]%s, %s)\n"+
				"    } else {\n"+
				"        %s = make(map[%s]%s)\n"+
				"    }\n",
			__mlen, name, KeyType, ValueType, __mlen, name, KeyType, ValueType,
		)

		__key, __value := ctx.nextName(), ctx.nextName()
		__i := ctx.nextName()
		//   for __i := uint64(0); __i < __mlen; __i++ {
		//       var __key <key>
		//       var __value <value>
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    for %s := uint64(0); %s < %s; %s++ {\n"+
				"        var %s %s\n"+
				"        var %s %s\n",
			__i, __i, __mlen, __i, __key, KeyType, __value, ValueType,
		)
		//	   <key> = <unmarshal body>
		//	   <value> = <unmarshal body>
		generateUnmarshalBody(ctx, __key, rt, v.Key())
		generateUnmarshalBody(ctx, __value, rt, v.Elem())

		//	   name[__key] = __value
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"        %s[%s] = %s\n",
			name, __key, __value,
		)
		//   }
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    }\n",
		)
	case *types.Slice:
		//    if uint64(len(src)) < offset+8 {
		//        return
		//    }
		//    _ = src[offset+7]
		//    var __slen uint64 = uint64(src[offset]) | uint64(src[offset+1])<<8 | uint64(src[offset+2])<<16 | uint64(src[offset+3])<<24 | uint64(src[offset+4])<<32 | uint64(src[offset+5])<<40 | uint64(src[offset+6])<<48 | uint64(src[offset+7])<<56
		//    offset += 8
		__slen := ctx.nextName()
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    if uint64(len(src)) < offset+8 {\n"+
				"        return\n"+
				"    }\n"+
				"    _ = src[offset+7]\n"+
				"    var %s uint64 = uint64(src[offset]) | uint64(src[offset+1])<<8 | uint64(src[offset+2])<<16 | uint64(src[offset+3])<<24 | uint64(src[offset+4])<<32 | uint64(src[offset+5])<<40 | uint64(src[offset+6])<<48 | uint64(src[offset+7])<<56\n"+
				"    offset += 8\n",
			__slen,
		)

		if isBasicType(v.Elem()) {
			if basicType(v.Elem()).Kind() == types.Byte {
				// []byte is a special case
				//    if uint64(len(src)) < offset+__slen {
				//        return
				//    }
				//    name = src[offset:offset+__slen]
				//    offset += __slen
				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					"    if uint64(len(src)) < offset+%s {\n"+
						"        return\n"+
						"    }\n"+
						"    %s = src[offset:offset+%s]\n"+
						"    offset += %s\n",
					__slen, name, __slen, __slen,
				)
				return
			}
		}

		// Pre-allocate slice if __slen is less than 32K
		//    if uint64(cap(name)) < __slen {
		//        if __slen <= 1<<15 {
		//            name = make([]<type>, __slen)
		//        } else {
		//            return
		//        }
		//    } else {
		//        name = name[:__slen]
		//    }
		Type := getTypeName(ctx, v.Elem())
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    if uint64(cap(%s)) < %s {\n"+
				"        if %s <= 1<<15 {\n"+
				"            %s = make([]%s, %s)\n"+
				"        } else {\n"+
				"            return\n"+
				"        }\n"+
				"    } else {\n"+
				"        %s = %s[:%s]\n"+
				"    }\n",
			name, __slen, __slen, name, Type, __slen, name, name, __slen,
		)

		//	for __i := uint64(0); __i < __slen; __i++ {
		//	    <unmarshal body>
		//	}
		__i := ctx.nextName()
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    for %s := uint64(0); %s < %s; %s++ {\n",
			__i, __i, __slen, __i,
		)
		generateUnmarshalBody(ctx, name+"["+__i+"]", rt, v.Elem())
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    }\n",
		)
	case *types.Array:
		if isBasicType(v.Elem()) {
			bt := basicType(v.Elem())
			if bt.Kind() == types.Byte {
				// if uint64(len(src)) < offset+<len> {
				//    return
				// }

				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					"    if uint64(len(src)) < offset+%d {\n"+
						"        return\n"+
						"    }\n",
					v.Len(),
				)

				if v.Len() <= 32 {
					//    _ = src[offset+31]
					//    name[i] = src[offset+i]
					//    offset += 32

					if v.Len() > 1 { // No BCE optimization for 1 byte
						ctx.Generated[rt] = fmt.Appendf(
							ctx.Generated[rt],
							"    _ = src[offset+%d]\n",
							v.Len()-1,
						)
					}
					for i := int64(0); i < v.Len(); i++ {
						ctx.Generated[rt] = fmt.Appendf(
							ctx.Generated[rt],
							"    %s[%d] = src[offset+%d]\n",
							name, i, i,
						)
					}
					ctx.Generated[rt] = fmt.Appendf(
						ctx.Generated[rt],
						"    offset += %d\n",
						v.Len(),
					)
					return
				}

				// NOTE: this is a special case for byte arrays
				//    copy(name[:], src[offset:])
				//    offset += <len>
				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					"    copy(%s[:], src[offset:])\n"+
						"    offset += %d\n",
					name, v.Len(),
				)
				return
			}
		}

		//    for __i := 0; __i < <length>; __i++ {
		//        <body>
		//    }
		__i := ctx.nextName()
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    for %s := 0; %s < %d; %s++ {\n",
			__i, __i, v.Len(), __i,
		)
		generateUnmarshalBody(ctx, name+"["+__i+"]", rt, v.Elem())
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    }\n",
		)
	case *types.Pointer:
		//    if uint64(len(src)) < offset+1 {
		//        return
		//    }
		//    if src[offset] == 1 {
		//        offset++
		//        if name == nil {
		//            name = new(<type>)
		//        }
		//        <body>
		//    } else {
		//        offset++
		//        name = nil
		//    }

		Type := getTypeName(ctx, v.Elem())
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    if uint64(len(src)) < offset+1 {\n"+
				"        return\n"+
				"    }\n"+
				"    if src[offset] == 1 {\n"+
				"        offset++\n"+
				"        if %s == nil {\n"+
				"            %s = new(%s)\n"+
				"        }\n",
			name, name, Type,
		)
		generateUnmarshalBody(ctx, "(*"+name+")", rt, v.Elem())
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    } else {\n"+
				"        offset++\n"+
				"        %s = nil\n"+
				"    }\n",
			name,
		)
	case *types.Named:
		if isBasicType(v.Underlying()) {
			bt := basicType(v.Underlying())
			if len(type_alias) > 0 {
				generateUnmarshalBody(ctx, name, rt, bt, type_alias[0])
			} else {
				generateUnmarshalBody(ctx, name, rt, bt, v)
			}
			return
		}

		//    __off, __ok := name.UnmarshalGOBE(src[offset:])
		//    offset += __off
		//    if !__ok {
		//        return
		//    }
		__off := ctx.nextName()
		__ok := ctx.nextName()
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    %s, %s := %s.UnmarshalGOBE(src[offset:])\n"+
				"    offset += %s\n"+
				"    if !%s {\n"+
				"        return\n"+
				"    }\n",
			__off, __ok, name, __off, __ok,
		)
	case *types.Basic:
		var Type string
		if len(type_alias) > 0 {
			Type = getTypeName(ctx, type_alias[0])
		} else {
			Type = getTypeName(ctx, v)
		}

		switch v.Kind() {
		case types.Bool:
			//    if uint64(len(src)) < offset+1 {
			//        return
			//    }
			//    name = src[offset] != 0
			//    offset++
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    if uint64(len(src)) < offset+1 {\n"+
					"        return\n"+
					"    }\n"+
					"    %s = src[offset] != 0\n"+
					"    offset++\n",
				name,
			)
		case types.Int, types.Int8, types.Int16, types.Int32, types.Int64,
			types.Uint, types.Uint8, types.Uint16, types.Uint32, types.Uint64, types.Uintptr:
			var size uint = 8
			switch v.Kind() {
			case types.Int8, types.Uint8:
				size = 1
			case types.Int16, types.Uint16:
				size = 2
			case types.Int32, types.Uint32:
				size = 4
			case types.Int64, types.Uint64, types.Uintptr:
				size = 8
			case types.Int, types.Uint:
				size = 8 // use 64bit for int
			}

			//    if uint64(len(src)) < offset+`size` {
			//        return
			//    }
			//    _ = src[offset+`size`-1]
			//    name = <type>(
			//        uint`size*8`(src[offset]) | uint`size*8`(src[offset+1])<<8 | ...
			//    )
			//    offset += `size`

			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    if uint64(len(src)) < offset+%d {\n"+
					"        return\n"+
					"    }\n"+
					"    _ = src[offset+%d]\n"+
					"    %s = %s(\n",
				size, size-1, name, Type,
			)
			for i := uint(0); i < size; i++ {
				if i != 0 {
					ctx.Generated[rt] = append(ctx.Generated[rt], '|')
				}
				ctx.Generated[rt] = fmt.Appendf(
					ctx.Generated[rt],
					"uint%d(src[offset+%d])<<%d",
					size*8, i, i*8,
				)
			}
			ctx.Generated[rt] = append(ctx.Generated[rt], ")\n"...)
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    offset += %d\n",
				size,
			)
		case types.Float32, types.Float64:
			var size uint = 0
			switch v.Kind() {
			case types.Float32:
				size = 4
			case types.Float64:
				size = 8
			}

			//    if uint64(len(src)) < offset+`size` {
			//        return
			//    }
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    if uint64(len(src)) < offset+%d {\n"+
					"        return\n"+
					"    }\n",
				size,
			)

			generateFloatUnmarshal(ctx, name, rt, t, size, Type)
		case types.Complex64, types.Complex128:
			var size uint = 0
			switch v.Kind() {
			case types.Complex64:
				size = 8
			case types.Complex128:
				size = 16
			}

			//    if uint64(len(src)) < offset+`size` {
			//        return
			//    }
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    if uint64(len(src)) < offset+%d {\n"+
					"        return\n"+
					"    }\n",
				size,
			)

			//    var __real, __imag float`size/2*8`
			//    <generateFloatUnmarshal(__real, size/2)>
			//    <generateFloatUnmarshal(__imag, size/2)>
			//    name = complex(__real, __imag)

			__real, __imag := ctx.nextName(), ctx.nextName()
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    var %s, %s float%d\n",
				__real, __imag, size/2*8,
			)
			generateFloatUnmarshal(ctx, __real, rt, t, size/2, fmt.Sprintf("float%d", (size/2)*8))
			generateFloatUnmarshal(ctx, __imag, rt, t, size/2, fmt.Sprintf("float%d", (size/2)*8))
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    %s = %s(complex(%s, %s))\n",
				name, Type, __real, __imag,
			)
		case types.String:
			//    if uint64(len(src)) < offset+8 {
			//        return
			//    }
			//    _ = src[offset+7]
			//    var __slen uint64 = uint64(src[offset]) | uint64(src[offset+1])<<8 | uint64(src[offset+2])<<16 | uint64(src[offset+3])<<24 | uint64(src[offset+4])<<32 | uint64(src[offset+5])<<40 | uint64(src[offset+6])<<48 | uint64(src[offset+7])<<56
			//    offset += 8
			__slen := ctx.nextName()
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    if uint64(len(src)) < offset+8 {\n"+
					"        return\n"+
					"    }\n"+
					"    _ = src[offset+7]\n"+
					"    var %s uint64 = uint64(src[offset]) | uint64(src[offset+1])<<8 | uint64(src[offset+2])<<16 | uint64(src[offset+3])<<24 | uint64(src[offset+4])<<32 | uint64(src[offset+5])<<40 | uint64(src[offset+6])<<48 | uint64(src[offset+7])<<56\n"+
					"    offset += 8\n",
				__slen,
			)

			//    if uint64(len(src)) < offset+__slen {
			//        return
			//    }
			//    name = string(src[offset:offset+__slen])
			//    offset += __slen
			ctx.Generated[rt] = fmt.Appendf(
				ctx.Generated[rt],
				"    if uint64(len(src)) < offset+%s {\n"+
					"        return\n"+
					"    }\n"+
					"    %s = %s(src[offset:offset+%s])\n"+
					"    offset += %s\n",
				__slen, name, Type, __slen, __slen,
			)
		}
	}
}

func generateFloatMarshal(ctx *GenerateContext, name string, __offset string, rt *types.Named, size uint) {
	__float := name
	if _, ok := ctx.LibAlias["math"]; !ok {
		ctx.LibAlias["math"] = ctx.nextName()
	}
	__math := ctx.LibAlias["math"]

	//	var __bits uint${size*8} = math.Float${size*8}bits(name)
	//  _ = dst[__offset+${size}-1]
	//	dst[__offset+0] = byte(__bits >> 0)...
	//  __offset += ${size}
	__bits := ctx.nextName()
	ctx.Generated[rt] = fmt.Appendf(
		ctx.Generated[rt],
		"    var %s uint%d = %s.Float%dbits(%s)\n",
		__bits, size*8, __math, size*8, __float,
	)

	ctx.Generated[rt] = fmt.Appendf(
		ctx.Generated[rt],
		"    _ = dst[%s+%d]\n",
		__offset, size-1,
	)

	for i := uint(0); i < size; i++ {
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"    dst[%s+%d] = byte(%s >> %d)\n",
			__offset, i, __bits, i*8,
		)
	}

	ctx.Generated[rt] = fmt.Appendf(
		ctx.Generated[rt],
		"    %s += %d\n",
		__offset, size,
	)
}

func generateFloatUnmarshal(ctx *GenerateContext, name string, rt *types.Named, _ types.Type, size uint, Type string) {
	if _, ok := ctx.LibAlias["math"]; !ok {
		ctx.LibAlias["math"] = ctx.nextName()
	}
	__math := ctx.LibAlias["math"]

	//    _ = src[offset+${size}-1]
	//    var __bits uint${size*8} = uint${size*8}(src[offset+0])<<0...
	//    name = math.Float${size*8}frombits(__bits)
	//    offset += ${size}
	__bits := ctx.nextName()
	ctx.Generated[rt] = fmt.Appendf(
		ctx.Generated[rt],
		"    _ = src[offset+%d]\n"+
			"    var %s uint%d = ",
		size-1, __bits, size*8,
	)
	for i := uint(0); i < size; i++ {
		if i != 0 {
			ctx.Generated[rt] = append(ctx.Generated[rt], '|')
		}
		ctx.Generated[rt] = fmt.Appendf(
			ctx.Generated[rt],
			"uint%d(src[offset+%d])<<%d",
			size*8, i, i*8,
		)
	}
	ctx.Generated[rt] = append(ctx.Generated[rt], '\n')
	ctx.Generated[rt] = fmt.Appendf(
		ctx.Generated[rt],
		"    %s = %s(%s.Float%dfrombits(%s))\n"+
			"    offset += %d\n",
		name, Type, __math, size*8, __bits, size,
	)
}

func isBasicType(t types.Type) bool {
	if _, ok := t.(*types.Basic); ok {
		return true
	}

	if _, ok := t.(*types.Named); ok {
		return isBasicType(t.(*types.Named).Underlying())
	}

	return false
}

func basicType(t types.Type) *types.Basic {
	if b, ok := t.(*types.Basic); ok {
		return b
	}

	if n, ok := t.(*types.Named); ok {
		return basicType(n.Underlying())
	}

	return nil
}

func getTypeName(ctx *GenerateContext, t types.Type) string {
	switch n := t.(type) {
	case *types.Pointer:
		return "*" + getTypeName(ctx, n.Elem())
	case *types.Slice:
		return "[]" + getTypeName(ctx, n.Elem())
	case *types.Map:
		return "map[" + getTypeName(ctx, n.Key()) + "]" + getTypeName(ctx, n.Elem())
	case *types.Chan:
		switch n.Dir() {
		case types.SendRecv:
			return "chan " + getTypeName(ctx, n.Elem())
		case types.SendOnly:
			return "chan<- " + getTypeName(ctx, n.Elem())
		case types.RecvOnly:
			return "<-chan " + getTypeName(ctx, n.Elem())
		}
	case *types.Signature:
		var params []string
		for i := 0; i < n.Params().Len(); i++ {
			params = append(params, getTypeName(ctx, n.Params().At(i).Type()))
		}
		var results []string
		for i := 0; i < n.Results().Len(); i++ {
			results = append(results, getTypeName(ctx, n.Results().At(i).Type()))
		}
		return fmt.Sprintf("func(%s) (%s)", strings.Join(params, ", "), strings.Join(results, ", "))
	case *types.Interface:
		var methods []string
		for i := 0; i < n.NumMethods(); i++ {
			methods = append(methods, getTypeName(ctx, n.Method(i).Type()))
		}
		return fmt.Sprintf("interface{%s}", strings.Join(methods, "; "))
	case *types.Struct:
		var fields []string
		for i := 0; i < n.NumFields(); i++ {
			if n.Field(i).Anonymous() {
				fields = append(fields, getTypeName(ctx, n.Field(i).Type()))
			} else {
				fields = append(fields, fmt.Sprintf("%s %s", n.Field(i).Name(), getTypeName(ctx, n.Field(i).Type())))
			}
		}
		return fmt.Sprintf("struct{%s}", strings.Join(fields, "; "))
	case *types.Array:
		return fmt.Sprintf("[%d]%s", n.Len(), getTypeName(ctx, n.Elem()))
	case *types.Basic:
		return n.String()
	case *types.Tuple:
		var fields []string
		for i := 0; i < n.Len(); i++ {
			fields = append(fields, getTypeName(ctx, n.At(i).Type()))
		}
		return fmt.Sprintf("(%s)", strings.Join(fields, ", "))
	case *types.Named:
		if ctx.RootPackage != n.Obj().Pkg() {
			// Auto Import
			var pkg string
			var ok bool
			pkg, ok = ctx.LibAlias[n.Obj().Pkg().Path()]
			if !ok {
				pkg = ctx.nextName()
				ctx.LibAlias[n.Obj().Pkg().Path()] = pkg
			}

			return pkg + "." + n.Obj().Name()
		}
		return n.Obj().Name()
	}

	return t.String()
}
